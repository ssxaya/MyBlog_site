---
title: 【功能测试】  测试用例的编写
date: 2025-04-01 20:56:46
tags: [功能测试,学习]
categories: [学习]
excerpt: "从字面上理解，就是测试时所使用的案例，这就是测试用例，也体现了测试用例最为重要的作用：指导我们测试的执行。"
---



## 测试用例的基本知识

### 测试用例的定义

从字面上理解，就是测试时所使用的案例，这就是测试用例，也体现了测试用例最为重要的作用：指导我们测试的执行

我们举一个实例吧，

qq邮箱登录模块：

![](https://img.ssxaya.fun/PicGo/posts/TestCase01.png)

与其对应的测试用例：

|     用例编号     | 项目名称   | 用例名称                                | 用例属性 | 重要等级 | 预置条件             | 测试数据                         | 测试步骤                                             | 预期结果                                  |
| :--------------: | ---------- | --------------------------------------- | -------- | -------- | -------------------- |------------------------------| ---------------------------------------------------- | ----------------------------------------- |
| QQMail-Login-001 | qq邮箱登录 | 填写正确的qq邮箱<br>账号密码并登录成功 | 功能测试 | 高       | qq邮箱账号已注册成功 | 用户名xxx@qq.com<br>密码 xxxxxxxx | 1.打开qq邮箱     2.填写qq邮箱账号密码     3.点击登录 | qq邮箱登录成功，进入     个人邮箱列表界面 |

可以看到，用例名提供了测试的目的，测试数据提供了我们测试应该输入哪些东西，测试步骤提供了我们自动化测试的过程等等...

显而易见，

**测试用例是为了特定的目的而设计的有一组有测试输入、执行条件、预期结果的案例**

<br>

<br>

### 测试用例的构成要素

从上文的测试用例例子可以看到，构成测试用例的常用基本要素有8种

#### 用例编号

用例的唯一标识，例如`QQMail_login_001`

``QQMail_login`起到了标识的作用

`001`包含了唯一性

<br>

#### 用例标题

用例的简要描述，

想要编写用例标题，我们可以参考其三要素：

在什么情况下 做什么事 有什么结果

<br>

#### 测试项目

用例所属的项目范畴，

<br>

#### 用例级别

用例的重要程度影响

对于一个测试项目或者系统来说，肯定有它主要的功能与次要的功能，而对于主要的功能（比如不能没有的功能），影响的范围很大，所以用例级别自然很高 

> 例如邮箱登录，自然是重要的，一般情况下会标一个优先级，例如`P1`
>
> 而对于那些用户使用次数相对小的，功能与出现概率相对次要的，可以标记成`P3`
>
> 可以能某一个错别字，显示的图片这些影响比较小的，可能标记成`P3`

<br>

#### 预置条件

用例执行的前提，

例如你想要测试qq邮箱的登录，是不是需要先让测试账号注册好了才能进行测试？

也就是说，我们用例的执行，需要依赖于什么事，例如环境、数据这些统统称之为**预置条件**

其次，预置条件并不是必要的

<br>

#### 测试输入

用例测试的数据输入

我们在测试时要准备的一些测试参数，需要输入的一些数据等等

<br>

#### 执行步骤

用例的测试步骤

当测试数据输入后，需要经过一系列的步骤做的事情

<br>

#### 预期结果

用例应该得到的结果

而上面两个加起来，则会得到**实际的结果**，我们拿来和预期结果（也就是应该得到的结果）进行比对，来决定这次用例是否成功

<br>

### 测试用例样例

| 用例编号         |  项目名称  |                用例名称                 | 用例属性 | 重要等级 |       预置条件       |                  测试数据                   |                       测试步骤                       |                 预期结果                  |
| ---------------- | :--------: | :-------------------------------------: | :------: | :------: | :------------------: | :-----------------------------------------: | :--------------------------------------------------: | :---------------------------------------: |
| QQMail-Login-001 | qq邮箱登录 | 填写正确的qq邮箱<br>账号密码并登录成功 | 功能测试 |    高    | qq邮箱账号已注册成功 |      用户名xxx@qq.com<br>密码 xxxxxxxx      | 1.打开qq邮箱<br>2.填写qq邮箱账号密码<br>3.点击登录 |   qq邮箱登录成功，进入个人邮箱列表界面    |
| QQMail-Login-002 | qq邮箱登录 | 填写正确的qq邮箱<br>账号密码后登陆失败 | 功能测试 |    中    | qq邮箱账号已注册成功 | 用户名xxx@qq.com<br>密码 xxxxxxxx(错误密码) | 1.打开qq邮箱<br>2.填写qq邮箱账号密码<br>3.点击登录 | qq邮箱登录失败，提示"邮箱账号或密码错误"= |

> 在实际工作中根据项目要求对用例要素可做调整，上述要素几乎覆盖常见的用例设计模板

<br>

<br>

<br>

## 黑盒测试用例的设计方法

### 导入

#### 什么是黑盒测试？

**黑盒测试**，又称为**功能测试**，是一种软件测试方法。它只控制测试软件系统的输入数据与得出的输出结果，来验证系统是否满足规定的功能需求和性能要求，而不需要了解其内部实现细节和代码结构。

也就是说，黑盒测试通过模拟用户的各种行为来测试项目进行测试，而不关心其内部代码结构以及别的部分

<br>

### 常见的黑盒测试用例设计方法

分别是 ：**等价类**、 **边界值**、 **判定表** 、**因果图**、 **正交实验**、 **状态迁移图**、 **场景法**、 **错误推测** 共八种。

<br>

<br>

### 等价类

> 假设我们有一个加法计算器，我们让其支持0到100之间的整数运算，我们只需要输入两个数据，此时若是使用穷举法就已经足够繁杂了，那么当要我们测试其支持0到1w、2w甚至输入数据量变多呢？穷举法肯定是不现实的。

#### 等价类的定义

等价类的概念：**在所有测试数据中，具有某种共同特征的数据子集**

在这个“所有的测试数据”中，指的是所有可能存在的测试数据，也就可能包含满足要求的数据或者不满足要求的数据，也就是说0到100的加法器中，可能包括0到100的数，也可能包括大于100的数，或者小于100的数。

而”具有某种共同特征的数据子集“，就是要把我们这些所有的数，把他们给分个类，给每个类的数据找到一个共同的特征

那我们该怎么分呢？

最简单的，我们根据用户需求进行分类，即 **满足要求的数据** 与 不**满足要求的数据**

我们称之为**有效等价类**和**无效等价类**：
![](https://img.ssxaya.fun/PicGo/posts/TestCase02.png)

> 在线性情况下，上图中不属于值域的部分都叫做无效等价类	

之前提到的加法器，小于0 并 大于100的部分则是无效等价类；大于等于0 并 小于等于100 的部分则是有效等价类，这是在线性的情况下

而非线性的情况下，例如c语言识别关键字的系统~~只是举个例子~~，关键字if for能被c语言编译器识别到，这些就是有效等价类，而其他无法被识别的非关键字，则称作无效等价类。

<br>

#### 等价类的划分规则

<br>

前面了解了等价类的定义，我们知道我们需要将测试输入根据需求来划分有效和无效等价类然后从有效等价类和无效等价类里面挑出来代表性的数据，那么等价类有什么普遍的划分规则呢？

一下是等价划分规则的一些例子：

| 输入数据类型                            | 划分等价类规则                                               |
| --------------------------------------- | ------------------------------------------------------------ |
| 数据个数 （例：手机号由11位组成）       | 1个有效等价类：正确数据个数（11位）<br>2个无效等价类：大于和小于数据个数（`num<11`, `num>11`） |
| 集合（例：电话号码都是数字组成）        | 1个有效等价类：正确数据集合<br>1个或多个无效等价类（非数字：包括字母、汉字、特殊字符等） |
| 符合某些规则的输入（例：手机号首位为1） | 多个有效等价类：符合某个规则的输入数据为1个等价类（首位为1）<br>若干个无效等价类（首位不为1） |
| 取值范围（例：输入0到100之间的整数）    | 1个有效等价类：正确取值范围（`0<num<100`）<br>2个无效等价类：大于和小于取值范围（`num<=0`, `num>=100`） |
| 布尔值（例：选择是否为男性）            | 1个有效等价类：`TRUE`<br>1个无效等价类：`FALSE`              |

<br>

#### 等价类设计用例的步骤

<br>

我们需要先分析需求，确定我们输入数据类型

紧接着使用规则划分有效无效等价类

<br>

##### 覆盖有效等价类

我们对于有效等价类而言，**一条用例尽可能多的覆盖有效等价类**

> 如果一条用例覆盖的有效等价类较多，那么编写的每条用例将会减少，最终可以提高我们的测试效率
>
> 因此一条用例尽可能多的覆盖有效等价类是有必要的

<br>

##### 覆盖无效等价类

那对于无效等价类来说，**一条用例只能覆盖一个无效等价类**

> 与有效等价类不同的是，在面对无效等价类时，设计用例往往目的是测试系统对于错误数据的输入处理情况。
>
> 如果一条用例覆盖了多个无效等价类，当测试结果不符合预期值时，想要找到其中哪个才是导致出错就会无法准确的定位错误点

<br>

<br>

#### 等价类设计测试用例的案例

例子：固定电话号码测试

地区码（3/4位）+电话号码（7/8位）

<br>

##### 设计流程：

- **分析需求，确定输入的数据类型**

    > 首先我们输入的是固定电话号码，而固定电话号码分为地区码和电话号码。
    > 其中地区码的数据类型是3/4位的整形数字；电话号码则是7/8位的整形数字。
    
| 输入(总)     | 输入(分) | 数据类型      |
| ------------ | -------- | ------------- |
| 固定电话号码 | 地区码   | 3/4的整形数字 |
|              | 电话号码 | 7/8的整型数字 |

<br>
    

- **根据输入的规则，划分有效和无效等价类**

    固定电话号码的输入规则比如长度、类型还有组成规则（地区码都是以0开头，电话号码则是非0非1开头）
| 输入(总)     | 输入(分) | 长度  | 类型 | 组成规则     |
| ------------ | -------- | ----- | ---- | ------------ |
| 固定电话号码 | 地区码   | 3-4位 | 数字 | 以0开头      |
|              | 电话号码 | 7-8位 | 数字 | 以非0非1开头 |

在了解规则后，就可以编写具体的有效等价类与无效等价类
| 输入(总)     | 输入(分) | 有效等价类                                           | 无效等价类                                                   |
| ------------ | -------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 固定电话号码 | 地区码   | 1.以0开头的3位数字<br />2.以0开头的4位数字       | 3.以0开头的小于3位的数字<br />4.以0开头的大于4位的数字<br />5.以0开头的包含非数字的4位字符串<br />6.以非0开头的4位数字 |
|              | 电话号码 | 7.以非0非1开头的7位数字<br />8.以非0非1开头的8位数字 | 9.以非0非1开头的小于7位的数字<br />10.以非0非1开头的大于8位的数字<br />11.以非0非1开头包含非数字的8位字符串<br />12.以0开头的8位数字 |

<br>
    
- **编写测试用例，覆盖有效与无效等价类**

| 输入     | 有效用例      |          | 无效用例      |        |
| -------- | ------------- | -------- | ------------- | ------ |
| 测试用例 | 012-3123456   | 覆盖1，7 | 01-3123456    | 覆盖3  |
|          | 012-31234567  | 覆盖3，8 | 01234-3123456 | 覆盖4  |
|          | 0123-3123456  | 覆盖2，7 | 01a-3123456   | 覆盖5  |
|          | 0123-31234567 | 覆盖2，8 | 1123-3123456  | 覆盖6  |
|          |               |          | 012-312345    | 覆盖9  |
|          |               |          | 012-312345678 | 覆盖10 |
|          |               |          | 012-3123ab56  | 覆盖11 |
|          |               |          | 012-01234567  | 覆盖12 |
|          |               |          | 012-11234567  | 覆盖13 |

<br>

<br>

### 边界值

> 大量的错误会发生在输入和输出范围的边界上，而不是在输入范围的内部

#### 边界值的定义

```c
num > -1 || num >= 0;
num >= -1 || num > 0; 
```

在代码层面，可以看到这两个表达式意思相近且不容易区分，不够老练的程序员很容易在这里写出错误。因此，有关于数据边界的bug相比于其它是显著增多的。

既然作为测试用例的设计者，自然也就要包含有关于边界值的测试——

**选取正好等于、刚刚好大于或刚刚好小于边界值作为测试数据**

#### 离点&内点

> 在边界值测试方法中，我们称位于边界值上数点的叫做**上点**，离上点最近的点且不在需求范围内的点叫做**离点**，在需求范围内的点叫**内点**。

<br>

我们以100以内的加法器为例子，它要求输入0到100的数字计算出来

它的上点则为 0，100

离点可能是 -1，1，99，101

内点则是在区间内的所有整数 50，49，48...

但在某些需求下，测试的数据点不会要求这么多

<br>

##### 闭区间  [0,100]   0 <= x <= 100

![](https://img.ssxaya.fun/PicGo/posts/TestCase03.png)

在闭区间中，上点和内点不变，但由于是闭区间，上点是属于符合区间的数的 ，那么1与99属于实际上属于内点（因为比上点更靠近符合区间的方向），也就没必要测试了，因此实际上测试的内点为-1，101即可。

> 上点：0，100
> 离点：-1，101
> 内点：50

<br>

##### 半开半闭区间 (0,100] 0 < x <= 100

![](https://img.ssxaya.fun/PicGo/posts/TestCase04.png)

> 上点：0，100
> 离点：1，101
> 内点：50

可以看到，相比于闭区间的边界值测试，这里的离点改变了，为什么呢？

我们可以思考一下，在(0,100] 区间中符合需求的区间是在 >0 且 <= 100，那么不符合的区间则是<= 0 且 > 100；因此0作为测试数据是不符合区间的数，既然0作为不符合区间的数。-1——一个比0更小的数，自然也是不符合区间的数，也就没必要测试-1。

<br>

##### 开区间  (0,100) 0 < x < 100

![](https://img.ssxaya.fun/PicGo/posts/TestCase05.png)

同样的，开区间的上点都是在无效区间，那么如果离点在上点的外侧，那么测得就没有意义，因此，在开区间里，离点都在上点的内侧，即1，99


> 上点：0，100
> 离点：1，99
> 内点：50


<br>

总而言之

**当上点在有效的符合区间时，这个上点的离点就要在无效区间，反之亦然。**

<br>

#### 边界值设计用例步骤

> 边界法测试用例本质上讲的是从边界选出具有代表性的数据来进行测试，而边界又是两个数值范围产生的，有范围才有边界。在某种意义上，边界值法还是从等价类划分演变而来的
> 因此，边界值法设计测试用例与等价类划分是十分类似的

<br>

##### 分析需求，确定输入数据类型

##### 使用规则划分有效和无效等价类

##### 确认上点、离点、内点

只有像范围，长度这样的等价类是包含边界的。类似规则、集合类的没有边界的则不适用于等价类划分。

##### 设计用例、覆盖有效等价类

一个用例要尽可能多的覆盖有效等价类

##### 设计用例、覆盖无效等价类

一个用例要只覆盖一条无效等价类

<br>

#### 边界值设计用例案例

我们还是以固定电话号码测试为例

地区码(3/4位) +电话号码(7/8位)



其他的与等价类划分相同，我们跳过一些步骤

##### 分析需求，确定输入的数据类型

| 输入(总)     | 输入(分) | 数据类型      |
| ------------ | -------- | ------------- |
| 固定电话号码 | 地区码   | 3/4的整形数字 |
|              | 电话号码 | 7/8的整型数字 |

#####  划分有效等价类无效等价类

| 输入(总)     | 输入(分) | 长度  | 类型 | 组成规则     |
| ------------ | -------- | ----- | ---- | ------------ |
| 固定电话号码 | 地区码   | 3-4位 | 数字 | 以0开头      |
|              | 电话号码 | 7-8位 | 数字 | 以非0非1开头 |

| 输入(总)     | 输入(分) | 有效等价类                                           | 无效等价类                                                   |
| ------------ | -------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 固定电话号码 | 地区码   | 1.以0开头的3位数字<br />2.以0开头的4位数字           | 3.以0开头的小于3位的数字<br />4.以0开头的大于4位的数字<br />5.以0开头的包含非数字的4位字符串<br />6.以非0开头的4位数字 |
|              | 电话号码 | 7.以非0非1开头的7位数字<br />8.以非0非1开头的8位数字 | 9.以非0非1开头的小于7位的数字<br />10.以非0非1开头的大于8位的数字<br />11.以非0非1开头包含非数字的8位字符串<br />12.以0开头的8位数字 |

#####  确定上点、离点、内点

根据上表，我们可以很清楚的确定上点、离点与内点：

<br>

###### 地区码

**合法输入：**

​	**边界内点：** 3位数字（以0开头），如 `010`，`001` 等。

​	**边界内点：** 4位数字（以0开头），如 `0123`，`0999` 等。

​	**边界下点：** 3位数字（以0开头），如 `009`，`010` 等。

​	**边界上点：** 4位数字（以0开头），如 `01234`，`0125` 等。

**非法输入：**

​	**下界无效：** 小于3位的数字，如 `01`。

​	**上界无效：** 大于4位的数字，如 `012345`。

​	**含有非数字字符的无效：** 如 `01a2`，`0abc` 等。

​	**非0开头的4位数字：** 如 `1234`。

###### 电话号码

**合法输入：**

​	**边界内点：** 7位数字（以非0非1开头），如 `2345678`。

​	**边界内点：** 8位数字（以非0非1开头），如 `23456789`。

​	**边界下点：** 7位数字（以非0非1开头），如 `2345670`，`2345671` 等。

​	**边界上点：** 8位数字（以非0非1开头），如 `23456789`，`23456788` 等。

**非法输入：**

​	**下界无效：** 小于7位的数字，如 `234567`，`23456`。

​	**上界无效：** 大于8位的数字，如 `234567890`，`234567891` 等。

​	**包含非数字字符的无效：** 如 `2345abc`，`23456@8` 等。

​	**以0开头的8位数字：** 如 `02345678`。

> 在这里，上点是指边界值的**上限**，即刚好等于最大允许值；下点是指边界值的**下限**，即刚好等于最小允许值。

**设计测试用例，覆盖有效无效等价类**

~~这里就不写了，作者有点懒(~~

![Static Badge](https://img.shields.io/badge/状态-待更新-brightgreen?style=flat-square)

<div align="center">
<a href="mailto:yanxiaoxaya@outlook.com">Email</a>  |  <a href="https://github.com/ssxaya">GitHub</a>  |  <a href="https://space.bilibili.com/359322078">Bilibili</a>
</div>