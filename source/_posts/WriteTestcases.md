---
title: 【功能测试】  测试用例的编写
date: 2025-04-01 20:56:46
tags: [功能测试,学习]
categories: [学习]
excerpt: "从字面上理解，就是测试时所使用的案例，这就是测试用例，也体现了测试用例最为重要的作用：指导我们测试的执行。"
---



## 测试用例的基本知识

### 测试用例的定义

从字面上理解，就是测试时所使用的案例，这就是测试用例，也体现了测试用例最为重要的作用：指导我们测试的执行

我们举一个实例吧，

qq邮箱登录模块：

![](https://img.ssxaya.fun/PicGo/posts/TestCase01.png)

与其对应的测试用例：

|     用例编号     | 项目名称   | 用例名称                                | 用例属性 | 重要等级 | 预置条件             | 测试数据                         | 测试步骤                                             | 预期结果                                  |
| :--------------: | ---------- | --------------------------------------- | -------- | -------- | -------------------- |------------------------------| ---------------------------------------------------- | ----------------------------------------- |
| QQMail-Login-001 | qq邮箱登录 | 填写正确的qq邮箱<br>账号密码并登录成功 | 功能测试 | 高       | qq邮箱账号已注册成功 | 用户名xxx@qq.com<br>密码 xxxxxxxx | 1.打开qq邮箱     2.填写qq邮箱账号密码     3.点击登录 | qq邮箱登录成功，进入     个人邮箱列表界面 |

可以看到，用例名提供了测试的目的，测试数据提供了我们测试应该输入哪些东西，测试步骤提供了我们自动化测试的过程等等...

显而易见，

**测试用例是为了特定的目的而设计的有一组有测试输入、执行条件、预期结果的案例**

<br>

<br>

### 测试用例的构成要素

从上文的测试用例例子可以看到，构成测试用例的常用基本要素有8种

#### 用例编号

用例的唯一标识，例如`QQMail_login_001`

``QQMail_login`起到了标识的作用

`001`包含了唯一性

<br>

#### 用例标题

用例的简要描述，

想要编写用例标题，我们可以参考其三要素：

在什么情况下 做什么事 有什么结果

<br>

#### 测试项目

用例所属的项目范畴，

<br>

#### 用例级别

用例的重要程度影响

对于一个测试项目或者系统来说，肯定有它主要的功能与次要的功能，而对于主要的功能（比如不能没有的功能），影响的范围很大，所以用例级别自然很高 

> 例如邮箱登录，自然是重要的，一般情况下会标一个优先级，例如`P1`
>
> 而对于那些用户使用次数相对小的，功能与出现概率相对次要的，可以标记成`P3`
>
> 可以能某一个错别字，显示的图片这些影响比较小的，可能标记成`P3`

<br>

#### 预置条件

用例执行的前提，

例如你想要测试qq邮箱的登录，是不是需要先让测试账号注册好了才能进行测试？

也就是说，我们用例的执行，需要依赖于什么事，例如环境、数据这些统统称之为**预置条件**

其次，预置条件并不是必要的

<br>

#### 测试输入

用例测试的数据输入

我们在测试时要准备的一些测试参数，需要输入的一些数据等等

<br>

#### 执行步骤

用例的测试步骤

当测试数据输入后，需要经过一系列的步骤做的事情

<br>

#### 预期结果

用例应该得到的结果

而上面两个加起来，则会得到**实际的结果**，我们拿来和预期结果（也就是应该得到的结果）进行比对，来决定这次用例是否成功

<br>

### 测试用例样例

| 用例编号         |  项目名称  |                用例名称                 | 用例属性 | 重要等级 |       预置条件       |                  测试数据                   |                       测试步骤                       |                 预期结果                  |
| ---------------- | :--------: | :-------------------------------------: | :------: | :------: | :------------------: | :-----------------------------------------: | :--------------------------------------------------: | :---------------------------------------: |
| QQMail-Login-001 | qq邮箱登录 | 填写正确的qq邮箱<br>账号密码并登录成功 | 功能测试 |    高    | qq邮箱账号已注册成功 |      用户名xxx@qq.com<br>密码 xxxxxxxx      | 1.打开qq邮箱<br>2.填写qq邮箱账号密码<br>3.点击登录 |   qq邮箱登录成功，进入个人邮箱列表界面    |
| QQMail-Login-002 | qq邮箱登录 | 填写正确的qq邮箱<br>账号密码后登陆失败 | 功能测试 |    中    | qq邮箱账号已注册成功 | 用户名xxx@qq.com<br>密码 xxxxxxxx(错误密码) | 1.打开qq邮箱<br>2.填写qq邮箱账号密码<br>3.点击登录 | qq邮箱登录失败，提示"邮箱账号或密码错误"= |

> 在实际工作中根据项目要求对用例要素可做调整，上述要素几乎覆盖常见的用例设计模板

<br>

<br>

<br>

## 黑盒测试用例的设计方法

### 导入

#### 什么是黑盒测试？

**黑盒测试**，又称为**功能测试**，是一种软件测试方法。它只控制测试软件系统的输入数据与得出的输出结果，来验证系统是否满足规定的功能需求和性能要求，而不需要了解其内部实现细节和代码结构。

也就是说，黑盒测试通过模拟用户的各种行为来测试项目进行测试，而不关心其内部代码结构以及别的部分

<br>

### 常见的黑盒测试用例设计方法

分别是 ：**等价类**、 **边界值**、 **判定表** 、**因果图**、 **正交实验**、 **状态迁移图**、 **场景法**、 **错误推测** 共八种。

<br>

<br>

### 等价类

> 假设我们有一个加法计算器，我们让其支持0到100之间的整数运算，我们只需要输入两个数据，此时若是使用穷举法就已经足够繁杂了，那么当要我们测试其支持0到1w、2w甚至输入数据量变多呢？穷举法肯定是不现实的。

#### 等价类的定义

等价类的概念：**在所有测试数据中，具有某种共同特征的数据子集**

在这个“所有的测试数据”中，指的是所有可能存在的测试数据，也就可能包含满足要求的数据或者不满足要求的数据，也就是说0到100的加法器中，可能包括0到100的数，也可能包括大于100的数，或者小于100的数。

而”具有某种共同特征的数据子集“，就是要把我们这些所有的数，把他们给分个类，给每个类的数据找到一个共同的特征

那我们该怎么分呢？

最简单的，我们根据用户需求进行分类，即 **满足要求的数据** 与 不**满足要求的数据**

我们称之为**有效等价类**和**无效等价类**：
![](https://img.ssxaya.fun/PicGo/posts/TestCase02.png)

> 在线性情况下，上图中不属于值域的部分都叫做无效等价类	

之前提到的加法器，小于0 并 大于100的部分则是无效等价类；大于等于0 并 小于等于100 的部分则是有效等价类，这是在线性的情况下

而非线性的情况下，例如c语言识别关键字的系统~~只是举个例子~~，关键字if for能被c语言编译器识别到，这些就是有效等价类，而其他无法被识别的非关键字，则称作无效等价类。

<br>

#### 等价类的划分规则

<br>

前面了解了等价类的定义，我们知道我们需要将测试输入根据需求来划分有效和无效等价类然后从有效等价类和无效等价类里面挑出来代表性的数据，那么等价类有什么普遍的划分规则呢？

一下是等价划分规则的一些例子：

| 输入数据类型                            | 划分等价类规则                                               |
| --------------------------------------- | ------------------------------------------------------------ |
| 数据个数 （例：手机号由11位组成）       | 1个有效等价类：正确数据个数（11位）<br>2个无效等价类：大于和小于数据个数（`num<11`, `num>11`） |
| 集合（例：电话号码都是数字组成）        | 1个有效等价类：正确数据集合<br>1个或多个无效等价类（非数字：包括字母、汉字、特殊字符等） |
| 符合某些规则的输入（例：手机号首位为1） | 多个有效等价类：符合某个规则的输入数据为1个等价类（首位为1）<br>若干个无效等价类（首位不为1） |
| 取值范围（例：输入0到100之间的整数）    | 1个有效等价类：正确取值范围（`0<num<100`）<br>2个无效等价类：大于和小于取值范围（`num<=0`, `num>=100`） |
| 布尔值（例：选择是否为男性）            | 1个有效等价类：`TRUE`<br>1个无效等价类：`FALSE`              |

<br>

#### 等价类设计用例的步骤

<br>

我们需要先分析需求，确定我们输入数据类型

紧接着使用规则划分有效无效等价类

<br>

##### 覆盖有效等价类

我们对于有效等价类而言，**一条用例尽可能多的覆盖有效等价类**

> 如果一条用例覆盖的有效等价类较多，那么编写的每条用例将会减少，最终可以提高我们的测试效率
>
> 因此一条用例尽可能多的覆盖有效等价类是有必要的

<br>

##### 覆盖无效等价类

那对于无效等价类来说，**一条用例只能覆盖一个无效等价类**

> 与有效等价类不同的是，在面对无效等价类时，设计用例往往目的是测试系统对于错误数据的输入处理情况。
>
> 如果一条用例覆盖了多个无效等价类，当测试结果不符合预期值时，想要找到其中哪个才是导致出错就会无法准确的定位错误点

<br>

<br>

#### 等价类设计测试用例的案例

例子：固定电话号码测试

地区码（3/4位）+电话号码（7/8位）

[待更新]

![Static Badge](https://img.shields.io/badge/状态-待更新-brightgreen?style=flat-square)